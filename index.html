// 1. Add this HTML to your info-box div (alongside your existing filters)

<div class="filter-section">
    <div class="filter-label">Filter by Town:</div>
    <select id="townFilter" class="filter-select">
        <option value="all">All Towns</option>
        <!-- Towns will be populated here dynamically -->
    </select>
</div>

// 2. Add these styles to your CSS section

.filter-section {
    margin-top: 15px;
}

.filter-select {
    width: 100%;
    padding: 6px;
    border-radius: 4px;
    border: 1px solid #ccc;
    font-size: 14px;
    margin-top: 5px;
}

// 3. Add this JavaScript to initialize the town dropdown
// (Place this in your initialize function or after data loads)

function populateTownDropdown() {
    if (!pointsData || pointsData.length === 0) return;
    
    const townDropdown = document.getElementById('townFilter');
    const towns = new Set();
    
    // Collect all unique towns
    pointsData.forEach(point => {
        if (point.town) {
            towns.add(point.town);
        }
    });
    
    // Sort towns alphabetically
    const sortedTowns = Array.from(towns).sort();
    
    // Add towns to dropdown
    sortedTowns.forEach(town => {
        const option = document.createElement('option');
        option.value = town;
        option.textContent = town;
        townDropdown.appendChild(option);
    });
    
    // Add event listener
    townDropdown.addEventListener('change', function() {
        if (pointsData && pointsData.length > 0 && map && deckOverlay) {
            createDeckLayer();
        }
    });
    
    console.log(`Populated town dropdown with ${sortedTowns.length} towns`);
}

// 4. Call this function after your data loads 
// Add this line at the end of your loadDataFromGCS function, right before or after createDeckLayer():
populateTownDropdown();

// 5. Modify your filterData function to include town filtering:

function filterData() {
    const minRank = parseInt(document.getElementById('rankMin').value);
    const maxRank = parseInt(document.getElementById('rankMax').value);
    const selectedTown = document.getElementById('townFilter').value;
    
    if (!pointsData) return [];
    
    return pointsData.filter(point => {
        if (!point || !point.position || !Array.isArray(point.position) || point.position.length !== 2) return false;
        
        // Apply rank filter
        const rank = point.DemandRank;
        const rankMatch = typeof rank === 'number' && !isNaN(rank) && rank >= minRank && rank <= maxRank;
        
        // Apply sidewalk filter
        let sidewalkMatch = true;
        if (currentSidewalkFilter === 'yes') {
            sidewalkMatch = point.Sidewalks === 1;
        } else if (currentSidewalkFilter === 'no') {
            sidewalkMatch = point.Sidewalks === 0;
        }
        
        // Apply town filter
        let townMatch = true;
        if (selectedTown !== 'all') {
            townMatch = point.town === selectedTown;
        }
        
        // Point must match all filters
        return rankMatch && sidewalkMatch && townMatch;
    });
}
